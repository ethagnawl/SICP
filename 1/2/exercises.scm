#|
Exercise 1.9
|#

(define (dec x) (- x 1))
; (dec 2) ; 1

(define (inc x) (+ x 1))
; (inc 1) ; 2

(define (my-plus a b)
  ; linear recursive
  (if (= a 0)
    b
    (inc (my-plus (dec a) b))))

; (my-plus 4 5)
; (my-plus 4 5)
; (inc (my-plus (dec 4) 5))
; (inc (my-plus 3 5))
; (inc (inc (my-plus (dec 3) 5)))
; (inc (inc (my-plus 2 5)))
; (inc (inc (inc (my-plus (dec 2) 5))))
; (inc (inc (inc (my-plus 1 5))))
; (inc (inc (inc (inc (my-plus (dec 1) 5)))))
; (inc (inc (inc (inc (my-plus 0 5)))))
; (inc (inc (inc (inc 5))))
; (inc (inc (inc 6)))
; (inc (inc 7))
; (inc 8)
; 9

(define (my-other-plus a b)
  ; linear iterative
  (if (= a 0)
    b
    (my-other-plus (dec a) (inc b))))

; (my-other-plus 4 5)
; (my-other-plus (dec 4) (inc 5))
; (my-other-plus 3 6)
; (my-other-plus (dec 3) (inc 6))
; (my-other-plus 2 7)
; (my-other-plus (dec 2) (inc 7))
; (my-other-plus 1 8)
; (my-other-plus (dec 1) (inc 8))
; (my-other-plus 0 9)
; 9


#|
Exercise 1.10
|#

(define (A x y)
  (cond ((= y 0) 0)
	((= x 0) (* 2 y))
	((= y 1) 2)
	(else (A (- x 1) (A x (- y 1))))))


(A 1 10) ; 1024
(A 2 4) ; 65536
(A 3 3) ; 65536


(define (f-iterative n) (A 0 n))

(f-iterative 0) ; 0
(f-iterative 1) ; 2
(f-iterative 2) ; 4
(f-iterative 3) ; 6


(define (g n) (A 1 n))

(g 0) ; 0
(g 1) ; 2
(g 2) ; 4
(g 3) ; 8


(define (h n) (A 2 n))

(h 0) ; 0
(h 1) ; 2
(h 2) ; 4
(h 3) ; 16
(h 4) ; 65536


(define (k n) (* 5 n n))

(k 0) ; 0
(k 1) ; 5
(k 2) ; 20
(k 3) ; 45
(k 4) ; 80


#|
Exercise 1.11
|#

(define (f-recursive n)
  (cond
    ((< n 3)
     n)
    (else
      (+  (f-recursive (- n 1))
      (* 2 (f-recursive (- n 2)))
      (* 3 (f-recursive (- n 3)))))))

(f-recursive 2) ; 2
(f-recursive 3) ; 4
(f-recursive 10) ; 1892


(define (f-iterative-iterate a b c n)
  ; (write "a:")
  ; (pretty-print a)
  ; (write "b:")
  ; (pretty-print b)
  ; (write "c:")
  ; (pretty-print c)
  ; (write "n:")
  ; (pretty-print n)
  (if (< n 3)
      a
      (f-iterative-iterate
      (+ a (* 2 b) (* 3 c))
      a
      b
      (- n 1))))

(define (f-iterative n) (f-iterative-iterate 2 1 0 n))

(f-iterative 2) ; 2
(f-iterative 3) ; 4
(f-iterative 10) ; 1892


#|
Exercise 1.12
|#

(define (pascal-tri dir row column)
  (write "dir")
  (pretty-print dir)
  (write "row")
  (pretty-print row)
  (write "column")
  (pretty-print column)
  (pretty-print "--------------")

  (cond ((or (< row 1) (< column 1) (> column row)) #f)
        ((or (= column 1) (= column row)) 1)
        (else (+ (pascal-tri "left" (- row 1) (- column 1)) (pascal-tri "right" (- row 1) column)))))

(pascal-tri "" 5 3)

#|
Exercise 1.13
|#

; not happening

#|
Exercise 1.14
|#

; space - linear - tree grows linearly with n
; steps - O(Nm)

(define (count-change amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(count-change 11)

#|
Exercise 1.15
#|

;; sin x = 3 * sin(x/3) - 4 * sin^3(x/3)

(define (cube x) (* x x x))

(define (p x counter)
  (pretty-print counter)
  (- (* 3 x) (* 4 (cube x))))
; (define (p x) (- (* 3 5) (* 4 125)))
; (define (p x) (- (15) (500)))
; (cube 5) => 125
; (p 5) => -485

(define (sine angle counter)
  (pretty-print counter)
  (if (not (> (abs angle) 0.1))
    angle
    (p (sine (/ angle 3.0) (+ 1 counter)))))

(sine 12.15 0)

; a) How many times is the procedure p applied when (sine 12.15) is evaluated?

; 5 times

; b) What is the order of growth in space and number of steps (as a function of
; a) used by the process generated by the sine procedure when (sine a) is
; evaluated?

; http://www.billthelizard.com/2009/12/sicp-exercise-115-calculating-sines.html
; The order of growth is O(ln(n)) for both space and steps.

; Space - The amount of space required by this procedure would increase
; linearly as the input size is tripled. Only the calls to procedure p are
; deferred, and we can triple the size of the input before an additional call
; would be made.

; Number of steps - It's also easy to see that we can triple the value of the
; starting input angle and only one more step would be required by this
; procedure.

#|
Exercise 1.16
|#

; https://github.com/psholtz/MIT-SICP/blob/master/Section-1.2/mit-scheme/exercise1-16.scm

(define (even? n) (= (remainder n 2) 0))

(define (square n) (* n n))

(define (fast-expt b n)
  (fast-expt-iter b n 1))

(define (fast-expt-iter b n a)
  (cond ((= n 0) a)
        ((even? n) (fast-expt-iter (square b) (/ n 2) a))
        (else
          (pretty-print "b")
          (pretty-print b)
          (pretty-print "n")
          (pretty-print (- n 1))
          (pretty-print "a")
          (pretty-print (* a b))

          (fast-expt-iter b (- n 1) (* a b)))))

(fast-expt 2 2)


#|
Exercise 1.17
|#

(define (double n) (+ n n))

(double 5) ; 10
(double 10) ; 20


(define (even? n) (= (remainder n 2) 0))

(even? 10) ; #t
(even? 11) ; #f


(define (halve n) (/ n 2))

(halve 10) ; 5
(halve 20) ; 10


(define (my-times n x)
  (cond ((= 0 x) 0)
        ((even? x) (double (* n (halve x))))
        (else (+ n (my-times n (- x 1))))))

(my-times 2 10) ; 20
(my-times 10 2) ; 20
(my-times 13 5) ; 65


#|
Exercise 1.18
|#

(define (my-new-times-iter n x memo)
  (cond ((= 0 x) memo)
        ((even? x) (my-new-times-iter (double n) (halve x) memo))
        (else (my-new-times-iter n (- x 1) (+ n memo)))))

(define (my-new-times n x)
  (my-new-times-iter n x 0))

(my-new-times 2 2) ; 4
(my-new-times 2 10) ; 20
(my-new-times 10 2) ; 20
(my-new-times 33 11) ; 363


#|
Exercise 1.19
|#

(define (square n) (* n n))

(define (sum-of-squares a b) (+ (square a) (square b)))

(define (log-fib-iter a b p q count)
  ; the Fibonacci numbers are produced by the nth power of the transformation
  ; T, or Tn, starting with the pair (1, 0).

  ; as usual, cribbed from:
  ; http://www.billthelizard.com/2010/01/sicp-exercise-119-computing-fibonacci.html
  ; and
  ; https://github.com/psholtz/MIT-SICP/blob/master/Section-1.2/mit-scheme/exercise1-19.scm

  (pretty-print "")
  (pretty-print "<--------")
  (pretty-print (~a "a:" a))
  (pretty-print (~a "b:" b))
  (pretty-print (~a "p:" p))
  (pretty-print (~a "q:" q))
  (pretty-print (~a "count:" count))
  (pretty-print "-------->")
  (pretty-print "")

  (cond ((= count 0) b)
        ((even? count)
         (log-fib-iter a
                       b
                       (sum-of-squares p q)
                       (+ (square q) (* 2 p q))
                       (/ count 2)))
        (else
          (log-fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))

(define (log-fib n)
  (log-fib-iter 1 0 0 1 n))

(log-fib 3) ; 2
(log-fib 4) ; 3
(log-fib 5) ; 5


#|
Exercise 1.20
|#

(define (gcd a b)
  (if (= b 0)
    a
    (gcd b (remainder a b))))

; http://www.billthelizard.com/2010/01/sicp-exercise-120-gcd.html
; normal - 18
; applicative - 4


#|
Exercise 1.21
|#

; cribbed from
; http://www.billthelizard.com/2010/01/sicp-exercise-121-smallest-divisor.html

; why do i need to keep defining this??
(define (square n) (* n n))

(define (divides? a b)
  (= (remainder b a) 0))

(divides? 4 2) ; #f
(divides? 2 4) ; #t

(define (find-divisor n test-divisor)

  ; you don't want this running during ex 1.22
  ; (pretty-print "")
  ; (pretty-print "<--------")
  ; (pretty-print (~a "n: " n))
  ; (pretty-print (~a "test-divisor: " test-divisor))
  ; (pretty-print "-------->")
  ; (pretty-print "")

  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (smallest-divisor n)
  (find-divisor n 2))

(smallest-divisor 199) ; 199

(smallest-divisor 1999) ; 1999

(smallest-divisor 19999) ; 7


#|
Exercise 1.22
|#

; cribbed from:
; https://github.com/psholtz/MIT-SICP/blob/master/Section-1.2/mit-scheme/exercise1-22.scm
; http://www.billthelizard.com/2010/02/sicp-exercise-122-timed-prime-test.html
; https://stackoverflow.com/questions/2195105/is-there-an-equivalent-to-lisps-runtime-primitive-in-scheme

(define (prime? n)
  (= n (smallest-divisor n)))

(prime? 3) ; #t
(prime? 4) ; #f

(define (report-prime n elapsed-time)
  (newline)
  (display n)
  (display " (")
  (display elapsed-time)
  (display ")"))

(define (start-prime-test n start-time)
  (cond ((prime? n)
         (report-prime n (- (current-inexact-milliseconds) start-time))
         #t)
        (else #f)))

(define (timed-prime-test n)
  (start-prime-test n (current-inexact-milliseconds)))

(define (search-for-primes a b)
  (define (search n)
    (cond ((<= n b) (timed-prime-test n)))
    (cond ((< n b) (search (+ n 2)))))
  (if (even? a)
    (search (+ a 1))
    (search a)))

(search-for-primes 1000 1050)

(search-for-primes 10000 10050)

(search-for-primes 100000 100050)

(define (search-for-n-primes a n)
  (define (search j c)
    (let ((next-j (+ j 2)))
      (cond ((< c n)
             (if (timed-prime-test j)
               (search next-j (+ c 1))
               (search next-j c))))))
  (if (even? a)
    (search (+ a 1) 0)
    (search a 0)))

(search-for-n-primes 1000 3)

(search-for-n-primes 10000 3)

(search-for-n-primes 100000 3)

(search-for-n-primes 1000000 3)


#|
Exercise 1.23
|#

; https://github.com/psholtz/MIT-SICP/blob/master/Section-1.2/mit-scheme/exercise1-23.scm

(define (new-find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (new-find-divisor n (next test-divisor)))))

(define (new-smallest-divisor n)
  (new-find-divisor n 2))

(define (new-prime? n)
  (= n (new-smallest-divisor n)))

(define (new-start-prime-test n start-time)
  (cond ((new-prime? n)
         (report-prime n (- (current-inexact-milliseconds) start-time))
         #t)
        (else #f)))

(define (new-timed-prime-test n)
  (new-start-prime-test n (current-inexact-milliseconds)))

(define (new-search-for-primes a b)
  (define (search n)
    (cond ((<= n b) (new-timed-prime-test n)))
    (cond ((< n b) (search (+ n 2)))))
  (if (even? a)
    (search (+ a 1))
    (search a)))

(new-search-for-primes 1000 1050)


#|
Exercise 1.24
|#

; http://www.billthelizard.com/2010/02/sicp-exercise-124-fermat-test.html

(define (square x) (* x x))

(define (ex124-fast-prime? n times)
  (cond ((= times 0) true)
        ((ex124-fermat-test n) (ex124-fast-prime? n (- times 1)))
        (else false)))

(define (ex124-start-prime-test n start-time)
  (cond ((ex124-fast-prime? n 100)
         (ex124-report-prime (-
                               (current-inexact-milliseconds)
                               start-time)))))

(define (ex124-timed-prime-test n)
  (newline)
  (display n)
  (ex124-start-prime-test n (current-inexact-milliseconds)))

(define (ex124-report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))

(define (ex124-expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (ex124-expmod base (/ exp 2) m))
                    m))
        (else
          (remainder (* base (ex124-expmod base (- exp 1) m))
                     m))))

(define (ex124-fermat-test n)
  ; r = n-1^n % n; r = n if n is prime
  (define (try-it a)
    (= (ex124-expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))

(define (ex124-search-for-primes a b)
  (define (search n)
    (cond ((<= n b) (ex124-timed-prime-test n)))
    (cond ((< n b) (search (+ n 2)))))
  (if (even? a)
    (search (+ a 1))
    (search a)))

(ex124-search-for-primes 1000 1050)


#|
Exercise 1.25
|#

; q. Would using fast-exp to simplify expmod have a negative effect on the
; performance of the fast-prime-tester?

; a. Yes.

; From the expmod source:
; The reduction steps in the cases where the exponent e is greater than 1 are
; based on the fact that, for any integers x, y, and m, we can find the
; remainder of x times y modulo m by computing separately the remainders of x
; modulo m and y modulo m, multiplying these, and then taking the remainder of
; the result modulo m. For instance, in the case where e is even, we compute
; the remainder of be/2 modulo m, square this, and take the remainder modulo m.
; This technique is useful because it means we can perform our computation
; without ever having to deal with numbers much larger than m.

; "The important point is that the original expmod procedure uses successive
; squaring to perform its computations without ever having to deal with numbers
; larger than m." -
; http://www.billthelizard.com/2010/02/sicp-exercise-125-closer-look-at-expmod.html

