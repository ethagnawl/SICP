#|
Exercise 1.9
|#

(define (dec x) (- x 1))
; (dec 2) ; 1

(define (inc x) (+ x 1))
; (inc 1) ; 2

(define (my-plus a b)
  ; linear recursive
  (if (= a 0)
    b
    (inc (my-plus (dec a) b))))

; (my-plus 4 5)
; (my-plus 4 5)
; (inc (my-plus (dec 4) 5))
; (inc (my-plus 3 5))
; (inc (inc (my-plus (dec 3) 5)))
; (inc (inc (my-plus 2 5)))
; (inc (inc (inc (my-plus (dec 2) 5))))
; (inc (inc (inc (my-plus 1 5))))
; (inc (inc (inc (inc (my-plus (dec 1) 5)))))
; (inc (inc (inc (inc (my-plus 0 5)))))
; (inc (inc (inc (inc 5))))
; (inc (inc (inc 6)))
; (inc (inc 7))
; (inc 8)
; 9

(define (my-other-plus a b)
  ; linear iterative
  (if (= a 0)
    b
    (my-other-plus (dec a) (inc b))))

; (my-other-plus 4 5)
; (my-other-plus (dec 4) (inc 5))
; (my-other-plus 3 6)
; (my-other-plus (dec 3) (inc 6))
; (my-other-plus 2 7)
; (my-other-plus (dec 2) (inc 7))
; (my-other-plus 1 8)
; (my-other-plus (dec 1) (inc 8))
; (my-other-plus 0 9)
; 9


#|
Exercise 1.10
|#

(define (A x y)
  (cond ((= y 0) 0)
	((= x 0) (* 2 y))
	((= y 1) 2)
	(else (A (- x 1) (A x (- y 1))))))


(A 1 10) ; 1024
(A 2 4) ; 65536
(A 3 3) ; 65536


(define (f-iterative n) (A 0 n))

(f-iterative 0) ; 0
(f-iterative 1) ; 2
(f-iterative 2) ; 4
(f-iterative 3) ; 6


(define (g n) (A 1 n))

(g 0) ; 0
(g 1) ; 2
(g 2) ; 4
(g 3) ; 8


(define (h n) (A 2 n))

(h 0) ; 0
(h 1) ; 2
(h 2) ; 4
(h 3) ; 16
(h 4) ; 65536


(define (k n) (* 5 n n))

(k 0) ; 0
(k 1) ; 5
(k 2) ; 20
(k 3) ; 45
(k 4) ; 80


#|
Exercise 1.11
|#

(define (f-recursive n)
  (cond
    ((< n 3)
     n)
    (else
      (+  (f-recursive (- n 1))
      (* 2 (f-recursive (- n 2)))
      (* 3 (f-recursive (- n 3)))))))

(f-recursive 2) ; 2
(f-recursive 3) ; 4
(f-recursive 10) ; 1892


(define (f-iterative-iterate a b c n)
  ; (write "a:")
  ; (pretty-print a)
  ; (write "b:")
  ; (pretty-print b)
  ; (write "c:")
  ; (pretty-print c)
  ; (write "n:")
  ; (pretty-print n)
  (if (< n 3)
      a
      (f-iterative-iterate
      (+ a (* 2 b) (* 3 c))
      a
      b
      (- n 1))))

(define (f-iterative n) (f-iterative-iterate 2 1 0 n))

(f-iterative 2) ; 2
(f-iterative 3) ; 4
(f-iterative 10) ; 1892


#|
Exercise 1.12
|#

(define (pascal-tri dir row column)
  (write "dir")
  (pretty-print dir)
  (write "row")
  (pretty-print row)
  (write "column")
  (pretty-print column)
  (pretty-print "--------------")

  (cond ((or (< row 1) (< column 1) (> column row)) #f)
        ((or (= column 1) (= column row)) 1)
        (else (+ (pascal-tri "left" (- row 1) (- column 1)) (pascal-tri "right" (- row 1) column)))))

(pascal-tri "" 5 3)

#|
Exercise 1.13
|#

; not happening

#|
Exercise 1.14
|#

; space - linear - tree grows linearly with n
; steps - O(Nm)

(define (count-change amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(count-change 11)

#|
Exercise 1.15
#|

;; sin x = 3 * sin(x/3) - 4 * sin^3(x/3)

(define (cube x) (* x x x))

(define (p x counter)
  (pretty-print counter)
  (- (* 3 x) (* 4 (cube x))))
; (define (p x) (- (* 3 5) (* 4 125)))
; (define (p x) (- (15) (500)))
; (cube 5) => 125
; (p 5) => -485

(define (sine angle counter)
  (pretty-print counter)
  (if (not (> (abs angle) 0.1))
    angle
    (p (sine (/ angle 3.0) (+ 1 counter)))))

(sine 12.15 0)

; a) How many times is the procedure p applied when (sine 12.15) is evaluated?

; 5 times

; b) What is the order of growth in space and number of steps (as a function of
; a) used by the process generated by the sine procedure when (sine a) is
; evaluated?

; http://www.billthelizard.com/2009/12/sicp-exercise-115-calculating-sines.html
; The order of growth is O(ln(n)) for both space and steps.

; Space - The amount of space required by this procedure would increase
; linearly as the input size is tripled. Only the calls to procedure p are
; deferred, and we can triple the size of the input before an additional call
; would be made.

; Number of steps - It's also easy to see that we can triple the value of the
; starting input angle and only one more step would be required by this
; procedure.

#|
Exercise 1.16
|#

; https://github.com/psholtz/MIT-SICP/blob/master/Section-1.2/mit-scheme/exercise1-16.scm

(define (even? n) (= (remainder n 2) 0))

(define (square n) (* n n))

(define (fast-expt b n)
  (fast-expt-iter b n 1))

(define (fast-expt-iter b n a)
  (cond ((= n 0) a)
        ((even? n) (fast-expt-iter (square b) (/ n 2) a))
        (else
          (pretty-print "b")
          (pretty-print b)
          (pretty-print "n")
          (pretty-print (- n 1))
          (pretty-print "a")
          (pretty-print (* a b))

          (fast-expt-iter b (- n 1) (* a b)))))

(fast-expt 2 2)


#|
Exercise 1.17
|#

(define (double n) (+ n n))

(double 5) ; 10
(double 10) ; 20


(define (even? n) (= (remainder n 2) 0))

(even? 10) ; #t
(even? 11) ; #f


(define (halve n) (/ n 2))

(halve 10) ; 5
(halve 20) ; 10


(define (my-times n x)
  (cond ((= 0 x) 0)
        ((even? x) (double (* n (halve x))))
        (else (+ n (my-times n (- x 1))))))

(my-times 2 10) ; 20
(my-times 10 2) ; 20
(my-times 13 5) ; 65


#|
Exercise 1.18
|#

(define (my-new-times-iter n x memo)
  (cond ((= 0 x) memo)
        ((even? x) (my-new-times-iter (double n) (halve x) memo))
        (else (my-new-times-iter n (- x 1) (+ n memo)))))

(define (my-new-times n x)
  (my-new-times-iter n x 0))

(my-new-times 2 2) ; 4
(my-new-times 2 10) ; 20
(my-new-times 10 2) ; 20
(my-new-times 33 11) ; 363


#|
Exercise 1.19
|#

(define (square n) (* n n))

(define (sum-of-squares a b) (+ (square a) (square b)))

(define (log-fib-iter a b p q count)
  ; the Fibonacci numbers are produced by the nth power of the transformation
  ; T, or Tn, starting with the pair (1, 0).

  ; as usual, cribbed from:
  ; http://www.billthelizard.com/2010/01/sicp-exercise-119-computing-fibonacci.html
  ; and
  ; https://github.com/psholtz/MIT-SICP/blob/master/Section-1.2/mit-scheme/exercise1-19.scm

  (pretty-print "")
  (pretty-print "<--------")
  (pretty-print (~a "a:" a))
  (pretty-print (~a "b:" b))
  (pretty-print (~a "p:" p))
  (pretty-print (~a "q:" q))
  (pretty-print (~a "count:" count))
  (pretty-print "-------->")
  (pretty-print "")

  (cond ((= count 0) b)
        ((even? count)
         (log-fib-iter a
                       b
                       (sum-of-squares p q)
                       (+ (square q) (* 2 p q))
                       (/ count 2)))
        (else
          (log-fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))

(define (log-fib n)
  (log-fib-iter 1 0 0 1 n))

(log-fib 3) ; 2
(log-fib 4) ; 3
(log-fib 5) ; 5


#|
Exercise 1.20
|#

(define (gcd a b)
  (if (= b 0)
    a
    (gcd b (remainder a b))))

; http://www.billthelizard.com/2010/01/sicp-exercise-120-gcd.html
; normal - 18
; applicative - 4


